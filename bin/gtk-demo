#!/usr/bin/python
import sys, time, array
import pygtk
pygtk.require("2.0")
import gtk, gobject
from snes import core

libsnes_path, game_path = sys.argv[1:]

core.init(libsnes_path)

with open(game_path, "rb") as handle:
	core.load_cartridge_normal(handle.read())

window = gtk.Window(gtk.WINDOW_TOPLEVEL)
vbox = gtk.VBox()
canvas = gtk.DrawingArea()

window.set_title("bsnes/Python")

window.add(vbox)
vbox.show()

canvas.set_size_request(256, 224)
vbox.pack_start(canvas)
canvas.show()
window.show()

drawable = canvas.window
gc = canvas.get_style().fg_gc[gtk.STATE_NORMAL]

framebuffer = array.array('B', [0] * (512*480*3))
framecount = 0.0
start = time.clock()

def decode_pixel(pixel):
	r = (pixel & 0x001f) << 3
	g = (pixel & 0x03e0) >> 2
	b = (pixel & 0x7c00) >> 7

	return array.array('B', [
			r | (r >> 5),
			g | (g >> 5),
			b | (b >> 5),
		])

rgb_lookup = [decode_pixel(p) for p in xrange(32768)]

def paint_frame(data, width, height, hires, interlace, overscan, pitch):
	global framecount, start

	now = time.clock()
	if now > start + 1:
		fps = framecount / (now - start)
		sys.stdout.write("FPS: %0.1f\r" % fps)
		sys.stdout.flush()
		framecount = 0
		start = now

	offset = 0
	for y in xrange(height):
		for x in xrange(width):
			pixel_data = data[pitch * y + x]
			framebuffer[offset:offset+3] = rgb_lookup[pixel_data]
			offset += 3

	drawable.draw_rgb_image(gc, 0,0, 256, 224, gtk.gdk.RGB_DITHER_NONE,
			framebuffer, -1)

	framecount += 1


core.set_video_refresh(paint_frame)

timeout_handle = gobject.timeout_add(1, lambda: core.run() or True)

def shutdown(widget, data=None):
	gobject.source_remove(timeout_handle)
	gtk.main_quit()

window.connect("destroy", shutdown)

gtk.main()
