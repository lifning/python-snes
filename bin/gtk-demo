#!/usr/bin/python
import sys, time, array
import pygtk
pygtk.require("2.0")
import gtk, gobject
from snes import core

libsnes_path, game_path = sys.argv[1:]

core.init(libsnes_path)

with open(game_path, "rb") as handle:
	core.load_cartridge_normal(handle.read())

window = gtk.Window(gtk.WINDOW_TOPLEVEL)
vbox = gtk.VBox()
canvas = gtk.DrawingArea()

window.set_title("bsnes/Python")

window.add(vbox)
vbox.show()

canvas.set_size_request(256, 224)
vbox.pack_start(canvas)
canvas.show()

window.show()

def iter_pixel_bytes(data, pitch, line, height):
	for y in range(height):
		line_width = line[y]
		for x in range(line_width):
			# pitch is in bytes, not pixels! Pity there's no good way to deal
			# with that.
			pixel_data = data[(pitch/2) * y + x]
			r = (pixel_data & 0x001f) << 3
			g = (pixel_data & 0x03e0) >> 2
			b = (pixel_data & 0x7c00) >> 7

			yield r | (r >> 5)
			yield g | (g >> 5)
			yield b | (b >> 5)

def paint_frame(data, pitch, line, width, height):
	drawable = canvas.window
	gc = canvas.get_style().fg_gc[gtk.STATE_NORMAL]
	colormap = gc.get_colormap()

	rgb_data = array.array('B', iter_pixel_bytes(data, pitch, line, height))

	drawable.draw_rgb_image(gc, 0,0, 256, 224, gtk.gdk.RGB_DITHER_NONE,
			rgb_data, -1)

core.set_video_refresh(paint_frame)

timeout_handle = gobject.timeout_add(1, lambda: core.run() or True)

def shutdown(widget, data=None):
	gobject.source_remove(timeout_handle)
	gtk.main_quit()

window.connect("destroy", shutdown)

gtk.main()
